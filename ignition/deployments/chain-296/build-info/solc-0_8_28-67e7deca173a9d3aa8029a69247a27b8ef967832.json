{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-67e7deca173a9d3aa8029a69247a27b8ef967832",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/LetsPayHBAR_V2_UUPS.sol": "project/contracts/LetsPayHBAR_V2_UUPS.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/LetsPayHBAR_V2_UUPS.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract LetsPayHBAR_V2_UUPS {\n    bool private _initialized;\n    modifier initializer() {\n        require(!_initialized, \"inited\");\n        _initialized = true;\n        _;\n    }\n\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"owner only\");\n        _;\n    }\n\n    bool private _entered;\n    modifier nonReentrant() {\n        require(!_entered, \"reentrant\");\n        _entered = true;\n        _;\n        _entered = false;\n    }\n\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    address private immutable __self = address(this);\n\n    modifier onlyProxy() {\n        require(address(this) != __self, \"UUPS: delegatecall only\");\n        require(_getImplementation() == __self, \"UUPS: not active impl\");\n        _;\n    }\n\n    constructor() {\n        _initialized = true;\n    }\n\n    function _getImplementation() internal view returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        assembly { impl := sload(slot) }\n    }\n\n    function proxiableUUID() external view returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    function upgradeTo(address newImplementation) external onlyOwner onlyProxy {\n        _upgradeToAndCallUUPS(newImplementation, \"\", false);\n    }\n\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable onlyOwner onlyProxy {\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        require(newImplementation.code.length > 0, \"UUPS: impl !contract\");\n        (bool ok, bytes memory ret) = newImplementation.staticcall(abi.encodeWithSignature(\"proxiableUUID()\"));\n        require(ok && ret.length == 32 && abi.decode(ret, (bytes32)) == _IMPLEMENTATION_SLOT, \"UUPS: invalid UUID\");\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            (bool s, bytes memory r) = newImplementation.delegatecall(data);\n            require(s, string(r));\n        }\n    }\n\n    function _setImplementation(address newImplementation) private {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        assembly { sstore(slot, newImplementation) }\n    }\n\n    uint256 public escrowCount;\n    // Changed from 1e18 to 1e8 to match HBAR's 8 decimal places (tinybars)\n    uint256 public constant CREDIT = 200 * 1e8;\n\n    mapping(address => uint256) public credit;\n    mapping(address => bool) public signedUp;\n\n    enum EscrowStatus { CREATED, PAID, SETTLED, CANCELLED }\n\n    struct Escrow {\n        address host;\n        address payable merchant;\n        uint256 total;\n        EscrowStatus status;\n        address[] participants;\n        uint256[] shares;\n    }\n\n    mapping(uint256 => Escrow) public escrows;\n    mapping(uint256 => mapping(address => bool)) public accepted;\n\n    event SignedUp(address indexed user, uint256 amount);\n    event EscrowCreated(uint256 indexed id, address indexed host, address indexed merchant, uint256 total);\n    event MerchantPaid(uint256 indexed id, address merchant, uint256 total);\n    event ParticipantAccepted(uint256 indexed id, address participant, uint256 amount);\n    event EscrowSettled(uint256 indexed id);\n    event ContractFunded(address indexed from, uint256 amount);\n    event CreditRepaid(address indexed user, uint256 amount);\n\n    function initialize(address owner_) external initializer onlyProxy {\n        require(owner_ != address(0), \"owner=0\");\n        owner = owner_;\n    }\n\n    function fundContract() external payable {\n        require(msg.value > 0, \"no value\");\n        emit ContractFunded(msg.sender, msg.value);\n    }\n\n    function signup() external {\n        require(!signedUp[msg.sender], \"already signed up\");\n        signedUp[msg.sender] = true;\n        credit[msg.sender] = CREDIT;\n        emit SignedUp(msg.sender, CREDIT);\n    }\n\n    function createEscrow(\n        address payable merchant,\n        address[] calldata otherParticipants,\n        uint256[] calldata otherShares,\n        uint256 total\n    ) external nonReentrant returns (uint256) {\n        require(otherParticipants.length == otherShares.length, \"len mismatch\");\n\n        uint256 sum = 0; for (uint i = 0; i < otherShares.length; i++) { sum += otherShares[i]; }\n        require(sum <= total, \"shares too big\");\n        uint256 hostShare = total - sum;\n        require(credit[msg.sender] >= hostShare, \"insufficient host credit\");\n        require(address(this).balance >= total, \"contract lacks funds\");\n\n        credit[msg.sender] -= total;\n        (bool ok, ) = merchant.call{value: total}(\"\");\n        require(ok, \"merchant payment failed\");\n        escrowCount++;\n        Escrow storage e = escrows[escrowCount];\n        e.host = msg.sender; e.merchant = merchant; e.total = total; e.status = EscrowStatus.PAID;\n        e.participants.push(msg.sender); e.shares.push(hostShare);\n        for (uint i = 0; i < otherParticipants.length; i++) { e.participants.push(otherParticipants[i]); e.shares.push(otherShares[i]); }\n\n        emit EscrowCreated(escrowCount, msg.sender, merchant, total);\n        emit MerchantPaid(escrowCount, merchant, total);\n        return escrowCount;\n    }\n\n    function accept(uint256 escrowId) external nonReentrant {\n        Escrow storage e = escrows[escrowId];\n        require(e.status == EscrowStatus.PAID, \"not payable\");\n        require(msg.sender != e.host, \"host auto-paid\");\n        uint idx = type(uint).max; for (uint i = 0; i < e.participants.length; i++) { if (e.participants[i] == msg.sender) { idx = i; break; } }\n        require(idx != type(uint).max, \"not participant\");\n        require(!accepted[escrowId][msg.sender], \"already accepted\");\n        uint256 amount = e.shares[idx];\n        require(credit[msg.sender] >= amount, \"insufficient credit\");\n        credit[msg.sender] -= amount; credit[e.host] += amount; accepted[escrowId][msg.sender] = true;\n        emit ParticipantAccepted(escrowId, msg.sender, amount);\n        bool all = true; for (uint i = 0; i < e.participants.length; i++) { if (e.participants[i] != e.host && !accepted[escrowId][e.participants[i]]) { all = false; break; } }\n        if (all) { e.status = EscrowStatus.SETTLED; emit EscrowSettled(escrowId); }\n    }\n\n    function cancelEscrow(uint256 escrowId) external nonReentrant {\n        Escrow storage e = escrows[escrowId];\n        require(msg.sender == e.host || msg.sender == owner, \"not allowed\");\n        require(e.status == EscrowStatus.PAID, \"wrong state\");\n        e.status = EscrowStatus.CANCELLED; credit[e.host] += e.total;\n    }\n\n    function getPendingEscrowsFor(address user) external view returns (uint256[] memory) {\n        uint256 cnt = 0;\n        for (uint i = 1; i <= escrowCount; i++) {\n            Escrow storage e = escrows[i];\n            if (e.status == EscrowStatus.PAID) {\n                for (uint j = 0; j < e.participants.length; j++) {\n                    if (e.participants[j] == user && e.participants[j] != e.host && !accepted[i][user]) { cnt++; break; }\n                }\n            }\n        }\n        uint256[] memory ids = new uint256[](cnt); uint k = 0;\n        for (uint i = 1; i <= escrowCount; i++) {\n            Escrow storage e = escrows[i];\n            if (e.status == EscrowStatus.PAID) {\n                for (uint j = 0; j < e.participants.length; j++) {\n                    if (e.participants[j] == user && e.participants[j] != e.host && !accepted[i][user]) { ids[k++] = i; break; }\n                }\n            }\n        }\n        return ids;\n    }\n\n    function escrowDetails(uint256 escrowId)\n        external view\n        returns (address host, address merchant, uint256 total, EscrowStatus status, address[] memory participants, uint256[] memory shares)\n    {\n        Escrow storage e = escrows[escrowId];\n        return (e.host, e.merchant, e.total, e.status, e.participants, e.shares);\n    }\n\n    function getUserHistory(address user)\n        external view\n        returns (\n            uint256[] memory ids,\n            address[] memory hosts,\n            address[] memory merchants,\n            uint256[] memory totals,\n            EscrowStatus[] memory statuses,\n            address[][] memory participantsList,\n            uint256[][] memory sharesList\n        )\n    {\n        uint256 cnt = 0;\n        for (uint i = 1; i <= escrowCount; i++) {\n            Escrow storage e = escrows[i];\n            if (e.host == user) { cnt++; }\n            else { for (uint j = 0; j < e.participants.length; j++) { if (e.participants[j] == user) { cnt++; break; } } }\n        }\n        ids = new uint256[](cnt); hosts = new address[](cnt); merchants = new address[](cnt); totals = new uint256[](cnt);\n        statuses = new EscrowStatus[](cnt); participantsList = new address[][](cnt); sharesList = new uint256[][](cnt);\n        uint k = 0;\n        for (uint i = 1; i <= escrowCount; i++) {\n            Escrow storage e = escrows[i]; bool involved = false;\n            if (e.host == user) { involved = true; }\n            else { for (uint j = 0; j < e.participants.length; j++) { if (e.participants[j] == user) { involved = true; break; } } }\n            if (involved) {\n                ids[k] = i; hosts[k] = e.host; merchants[k] = e.merchant; totals[k] = e.total; statuses[k] = e.status; participantsList[k] = e.participants; sharesList[k] = e.shares; k++;\n            }\n        }\n    }\n\n    function repayCredit() external payable nonReentrant {\n        require(msg.value > 0, \"no value\");\n        credit[msg.sender] += msg.value;\n        emit CreditRepaid(msg.sender, msg.value);\n    }\n\n    receive() external payable {}\n}"
      }
    }
  }
}