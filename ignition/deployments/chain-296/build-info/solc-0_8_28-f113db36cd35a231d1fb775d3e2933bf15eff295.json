{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-f113db36cd35a231d1fb775d3e2933bf15eff295",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ERC1967Proxy.sol": "project/contracts/ERC1967Proxy.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ERC1967Proxy.sol": {
        "content": "// ERC1967Proxy.sol â€” minimal UUPS-compatible proxy (no admin)\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title ERC1967 Proxy (minimal)\n * @dev Stores implementation at EIP-1967 slot and delegates all calls. No admin functions.\n */\ncontract ERC1967Proxy {\n    // keccak256(\"eip1967.proxy.implementation\") - 1\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    constructor(address _implementation, bytes memory _data) payable {\n        require(_implementation != address(0), \"impl=0\");\n        assembly { sstore(_IMPLEMENTATION_SLOT, _implementation) }\n        if (_data.length > 0) {\n            (bool ok, bytes memory ret) = _implementation.delegatecall(_data);\n            require(ok, string(ret));\n        }\n    }\n\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        assembly { impl := sload(slot) }\n    }\n\n    fallback() external payable {\n        address impl = _implementation();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(0, 0, size)\n            switch result\n            case 0 { revert(0, size) }\n            default { return(0, size) }\n        }\n    }\n\n    receive() external payable { }\n}"
      }
    }
  }
}